"use strict";(self.webpackChunkgeogardenclub_github_io=self.webpackChunkgeogardenclub_github_io||[]).push([[426],{8463:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>r,contentTitle:()=>l,default:()=>h,frontMatter:()=>a,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"develop/design/collection-classes","title":"Collection classes","description":"As documented in the Document Data Model, GGC entities are persisted in a set of \\"flat\\" Firestore collections.  We chose this design because the set of entities are highly interrelated, making it problematic to \\"nest\\" collections within other collections.","source":"@site/docs/develop/design/collection-classes.md","sourceDirName":"develop/design","slug":"/develop/design/collection-classes","permalink":"/docs/develop/design/collection-classes","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"hide_table_of_contents":false},"sidebar":"developSidebar","previous":{"title":"Retail Value","permalink":"/docs/develop/design/retail-value"},"next":{"title":"Coding Standards","permalink":"/docs/develop/quality-assurance/coding-standards"}}');var n=s(4848),i=s(8453);const a={hide_table_of_contents:!1},l="Collection classes",r={},c=[];function d(e){const t={a:"a",code:"code",h1:"h1",header:"header",li:"li",ol:"ol",p:"p",...(0,i.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.header,{children:(0,n.jsx)(t.h1,{id:"collection-classes",children:"Collection classes"})}),"\n",(0,n.jsxs)(t.p,{children:["As documented in the ",(0,n.jsx)(t.a,{href:"/docs/develop/data-model/document-data-model",children:"Document Data Model"}),', GGC entities are persisted in a set of "flat" Firestore collections.  We chose this design because the set of entities are highly interrelated, making it problematic to "nest" collections within other collections.']}),"\n",(0,n.jsx)(t.p,{children:"In order to actually display and manipulate entities within the app, we must solve two problems:"}),"\n",(0,n.jsxs)(t.ol,{children:["\n",(0,n.jsx)(t.li,{children:'For scalability reasons, the app cannot simply "mirror" the entire Firestore database to each client\'s device.  Since GGC is intended to grow to hundreds of chapters, thousands of users, and hundreds of thousands (if not millions) of gardening data documents, downloading the entire database to each device would degrade the performance to an unacceptable level. Instead, each device should hold only a small subset of the database appropriate to the desired functionality.'}),"\n",(0,n.jsxs)(t.li,{children:['While a "flat" database structure is convenient as a database design, it is not optimal within the app.  For example, there are multiple screens in the app that need to display the set of users who are editors of a garden. It is far more appropriate for these clients to have a method like ',(0,n.jsx)(t.code,{children:"getEditors(gardenID)"}),", as opposed to retrieving the garden collection, retrieving the editor collection, and performing a join and select."]}),"\n"]}),"\n",(0,n.jsx)(t.p,{children:'To solve the first problem, the app implements a "Collection Class" for each of the domain entities.  So, there is a "PlantingCollection" class that provides access to all the Planting entities, an "EditorCollection" class that provides access to all the Editor entities, and so forth.  These collection classes provide methods to find one or more entities given some sort of search criteria (such as their ID). These classes do not "mirror" the entire database, but rather hold only the set of entities necessary for the app to function for a particular screen.'}),"\n",(0,n.jsxs)(t.p,{children:["To solve the second problem, the app implements three special collection classes: GardenCollection, ChapterCollection, and UserCollection that are used in conjunction with the ",(0,n.jsx)(t.a,{href:"/docs/develop/design/with-widgets",children:"With Widgets"})," design pattern. These three collection classes not only hold local copies of their corresponding entities (Garden, Chapter, and User, respectively), they also hold pointers to related CollectionClasses. These three collection instances are typically bound to variables called ",(0,n.jsx)(t.code,{children:"gardens"}),", ",(0,n.jsx)(t.code,{children:"chapters"}),", and ",(0,n.jsx)(t.code,{children:"users"})," in client code."]}),"\n",(0,n.jsxs)(t.p,{children:["So, for example, the GardenCollection class also holds pointers to instances of the GardenerCollection and EditorCollection classes (among others).  The ChapterCollection class also holds pointers to instances of the ObservationCollection and PriceCollection classes (among others). Finally, the UserCollection class holds pointers to instances of the RoleCollection class (among others).  The makes it possible to (for example) determine the editors associated with a garden by calling ",(0,n.jsx)(t.code,{children:"gardens.getEditorUserIDs(gardenID)"}),", or the Bed entities associated with a Garden by calling ",(0,n.jsx)(t.code,{children:"gardens.getBeds(gardenID)"}),"."]}),"\n",(0,n.jsx)(t.p,{children:"This design means that although there are over 30 entities and collection classes, clients can always access whatever data they need by calling methods (or accessing fields) in just three classes: ChapterCollection, GardenCollection, and UserCollection.  It also means that when we add (or delete) collections as the design evolves, the impact on clients is only the addition (or deletion) of methods (or fields)."})]})}function h(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(d,{...e})}):d(e)}},8453:(e,t,s)=>{s.d(t,{R:()=>a,x:()=>l});var o=s(6540);const n={},i=o.createContext(n);function a(e){const t=o.useContext(i);return o.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:a(e.components),o.createElement(i.Provider,{value:t},e.children)}}}]);