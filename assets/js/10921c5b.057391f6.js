"use strict";(self.webpackChunkgeogardenclub_github_io=self.webpackChunkgeogardenclub_github_io||[]).push([[152],{7556:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>c,frontMatter:()=>s,metadata:()=>a,toc:()=>d});const a=JSON.parse('{"id":"develop/design/with-widgets","title":"\\"With\\" widgets","description":"Why \\"with\\"?","source":"@site/docs/develop/design/with-widgets.md","sourceDirName":"develop/design","slug":"/develop/design/with-widgets","permalink":"/docs/develop/design/with-widgets","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"hide_table_of_contents":true},"sidebar":"developSidebar","previous":{"title":"Input Management","permalink":"/docs/develop/design/input-management"},"next":{"title":"Data Mutation","permalink":"/docs/develop/design/data-mutation"}}');var r=n(4848),i=n(8453);const s={hide_table_of_contents:!0},o='"With" widgets',l={},d=[{value:"Why &quot;with&quot;?",id:"why-with",level:2},{value:"WithMonarchData",id:"withmonarchdata",level:2},{value:"WithGardenData, etc",id:"withgardendata-etc",level:2}];function h(e){const t={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.header,{children:(0,r.jsx)(t.h1,{id:"with-widgets",children:'"With" widgets'})}),"\n",(0,r.jsx)(t.h2,{id:"why-with",children:'Why "with"?'}),"\n",(0,r.jsxs)(t.p,{children:["As noted in the ",(0,r.jsx)(t.a,{href:"/docs/develop/architecture",children:"Architecture documentation"}),', one important issue to address in a client-server system is the asynchronous nature of client-server communication. For example, when the client needs data from the server, it makes a request that can take time to complete, and may not complete successfully.  The client UI should not simply "freeze" during this time, and should "fail gracefully" if the request does not complete successfully.  As the following diagram from the Architecture section illustrates, we have implemented a design pattern we call With Widgets to address the asynchronous nature of data retrieval:']}),"\n",(0,r.jsx)("img",{src:"/img/develop/ggc-dataflow-diagram.png"}),"\n",(0,r.jsx)(t.p,{children:'Making things even more complicated is the desire for modern UIs to be "reactive". This means that if the server\'s database content changes (for example, one user creates a new garden), then all the other clients currently connected should see their UI automatically refresh with updated information (for example, the number of gardens in the Chapter should increase by one for all other users.)'}),"\n",(0,r.jsx)(t.p,{children:'In GGC, we address these issues through a design pattern that involves a set of widgets which we call the "With" widgets: WithAllData, WithCoreData, WithGardenData, WithMonarchData, WithObservationData, and so on.'}),"\n",(0,r.jsx)(t.p,{children:'In this design pattern, each With widget is responsible for querying the database, retrieving individual entities from the 16 or so Firebase collections, and organizing this data into three "top-level" client-side classes (ChapterCollection, GardenCollection, and UserCollection) which are then provided to the UI code for use in building the screen contents.'}),"\n",(0,r.jsx)(t.p,{children:'In addition, UI widgets come in two basic flavors, "Screens" and "Views".  Screens are a kind of "top-level" UI widget which must take responsibility for building the ChapterCollection, GardenCollection, and UserCollection classes. They accomplish this by invoking a "With" widget.  Views are always a "child" of a Screen widget, and must be passed ChapterCollection, GardenCollection, and UserCollection instances from their parent Widget. So, database access always happens at the Screen-level, and from then on the Views all receive locally cached data.'}),"\n",(0,r.jsx)(t.p,{children:'To support the use of Monarch, each Screen is implemented by two Widgets: the Widget that calls (for example) WithCoreData in its build method, and then invokes an "Internal" widget with populated instances of ChapterCollection, GardenCollection, and UserCollection. The two-widget structure is necessary in order to support Monarch storybooks, as will be demonstrated later below.'}),"\n",(0,r.jsx)(t.p,{children:"Let's see a simple example of the use of WithCoreData:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-dart",children:"class ChaptersScreen extends StatelessWidget {\n  const ChaptersScreen({\n    super.key,\n  });\n\n  @override\n  Widget build(BuildContext context) {\n    return WithCoreData(whenCoreData: (\n        {required ChapterCollection chapters,\n        required GardenCollection gardens,\n        required UserCollection users}) {\n      return ChaptersScreenInternal(\n          chapters: chapters, gardens: gardens, users: users);\n    });\n  }\n}\n"})}),"\n",(0,r.jsx)(t.p,{children:'In a nutshell, when the ChaptersScreen widget\'s build method is called, it will call WithCoreData.  WithCoreData will retrieve the "core" Chapter, Garden, and User data from Firebase (the first time it is called during a session---after that, the local Riverpod cache of the documents will be used). Note that core data includes documents from a variety of Firebase collections, including chapters, gardens, users, crops, badges.'}),"\n",(0,r.jsx)(t.p,{children:'While this retrieval process is going on, this "With" widget will display the CircularProgressIndicator widget. Once all the core data is successfully retrieved, then the ChaptersScreenInternal widget\'s build method will be called and passed these fully populated collection class instances, and the intended screen UI will appear. If an error occurs during database retrieval, the "With" widget will display a generic error page.'}),"\n",(0,r.jsx)(t.p,{children:'The net effect is that the UI code is insulated from technicalities resulting from the asynchronous nature of data retrieval.  It just wraps the code for the "happy path" inside a "With" widget and proceeds. For example, here\'s an elided version of the "Internal" widget:'}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-dart",children:"class ChaptersScreenInternal extends StatelessWidget {\n  const ChaptersScreenInternal({\n    Key? key,\n    required this.chapters,\n    required this.gardens,\n    required this.users,\n  }) : super(key: key);\n  final ChapterCollection chapters;\n  final GardenCollection gardens;\n  final UserCollection users;\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      drawer: DrawerView(currentUser: users.currentUser),\n      appBar: AppBar(\n        title: Text('Chapters (${chapters.size()})'),\n        actions: [HelpButton(routeName: AppRoute.chapters.name)],\n      ),\n      body: ListView(children: [...]),\n      bottomNavigationBar: BottomNavigationBar(...),\n    );\n  }\n}\n"})}),"\n",(0,r.jsx)(t.p,{children:"What's nice about this approach is that ChaptersScreenInternal is a StatelessWidget that gets passed three collections: Chapters, Gardens, and Users, and this is all the data that it (or any of its component Views) should need to render the Screen."}),"\n",(0,r.jsx)(t.p,{children:'As you look through the code, you will see that Screen widgets generally follow this design pattern:  a "top-level" Widget that calls WithCoreData, along with a callback that calls the corresponding "Internal" widget with the three collection classes (and potentially some other data).'}),"\n",(0,r.jsx)(t.h2,{id:"withmonarchdata",children:"WithMonarchData"}),"\n",(0,r.jsx)(t.p,{children:'The decomposition of a Screen into a top-level widget and an internal widget is an important design pattern in ggc_app because it makes it easy to implement Monarch stories.  You can do this by writing a story that first calls WithMonarchData, and then calls the "Internal" widget with the collections created by WithMonarchData.'}),"\n",(0,r.jsx)(t.p,{children:"For example:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-dart",children:"Widget showChaptersScreen() {\n  return WithMonarchData(whenMonarchData: (\n      {required ChapterCollection chapters,\n      required GardenCollection gardens,\n      required UserCollection users}) {\n    return ChaptersScreenInternal(\n        chapters: chapters, gardens: gardens, users: users);\n  });\n}\n"})}),"\n",(0,r.jsx)(t.p,{children:"The difference between WithCoreData and WithMonarchData is that WithCoreData builds the Chapters, Gardens, and Users collections by accessing Firestore, while WithMonarchData builds the Chapters, Gardens, and Users collections from sample data stored in the assets/monarch directory."}),"\n",(0,r.jsx)(t.p,{children:"What makes Monarch so useful for UI development is that it makes it really easy to display a UI component in different states. For example, here is an example of displaying the Drawer UI component with data from two different users (one with a profile picture, one who does not):"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-dart",children:"Widget showDrawer() {\n  return WithMonarchData(whenMonarchData: (\n      {required ChapterCollection chapters,\n        required GardenCollection gardens,\n        required UserCollection users}) {\n    return DrawerView(currentUser: users.getUser('jennacorindeane@gmail.com'));\n  });\n}\n\nWidget showDrawer2() {\n  return WithMonarchData(whenMonarchData: (\n      {required ChapterCollection chapters,\n        required GardenCollection gardens,\n        required UserCollection users}) {\n    return DrawerView(currentUser: users.getUser('johnson@hawaii.edu'));\n  });\n}\n"})}),"\n",(0,r.jsx)(t.p,{children:"To view these two states using the emulator, you would have to login and logout multiple times."}),"\n",(0,r.jsxs)(t.admonition,{type:"warning",children:[(0,r.jsx)(t.p,{children:'These "Screen" and "View" design patterns in ggc_app have some important constraints:'}),(0,r.jsxs)(t.ol,{children:["\n",(0,r.jsx)(t.li,{children:'Only Screen widgets call a "With" widget.  All View widgets should be passed the Chapter, User, and Garden collections from their parents.'}),"\n",(0,r.jsx)(t.li,{children:'Neither Screen nor View widgets call Riverpod providers.  All the Riverpod providers are called within the "With" widgets.'}),"\n"]})]}),"\n",(0,r.jsx)(t.h2,{id:"withgardendata-etc",children:"WithGardenData, etc"}),"\n",(0,r.jsx)(t.p,{children:'WithCoreData is responsible for retrieving "core" data, which means the data that is necessary to build the initial set of Screens that the user sees after logging in. We don\'t want to retrieve all the data that the user might ever want to see immediately upon logging in, as that might require the UI to pause for several-to-many seconds, degrading the user experience. Instead, upon logging in, only the minimum "core" data is retrieved from the database so that the wait time is minimal.'}),"\n",(0,r.jsx)(t.p,{children:'Now, consider the situation where the user wants to navigate to the Garden Details screen.  This screen will require (among other things) all the Planting data associated with that specific garden. To retrieve additional data beyond the core data, we will provide additional "With" widgets, of which WithGardenData is an example.'}),"\n",(0,r.jsx)(t.p,{children:"Here's an example invocation of WithGardenData:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-dart",children:"class GardenDetailsScreen extends StatelessWidget {\n  const GardenDetailsScreen({\n    required this.gardenID,\n    super.key,\n  });\n\n  final String gardenID;\n  @override\n  Widget build(BuildContext context) {\n    return WithGardenData(\n        gardenID: gardenID,\n        whenGardenData: (\n            {required ChapterCollection chapters,\n            required GardenCollection gardens,\n            required UserCollection users}) {\n          return GardenDetailsScreenInternal(gardenID: gardenID,\n              chapters: chapters, gardens: gardens, users: users);\n        });\n  }\n}\n"})}),"\n",(0,r.jsx)(t.p,{children:"Notice that WithGardenData takes two arguments, a gardenID (used to determine which garden's detailed data to retrieve), plus the standard callback that will be passed filled out instances of ChapterCollection, GardenCollection, and UserCollection. For convenience, the GardenDetailsScreenInternal widget is passed the gardenID as well."}),"\n",(0,r.jsx)(t.p,{children:'It is important to note that "extended" With widgets like WithGardenData call WithCoreData internally, so the resulting collection instances include all the core data, plus (in this case) the garden details data.  As a result, the client code never needs to nest multiple With widgets.'}),"\n",(0,r.jsx)(t.p,{children:"Due to the wonders of Riverpod, data is cached and reactive.  The user can navigate away from this garden and return to it later and the system will build the collections from local copies of the data. Even better, Riverpod will keep its local copies in sync with Firebase, so that if other users add data, the current user will see the updates when they redisplay the page."})]})}function c(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(h,{...e})}):h(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>s,x:()=>o});var a=n(6540);const r={},i=a.createContext(r);function s(e){const t=a.useContext(i);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),a.createElement(i.Provider,{value:t},e.children)}}}]);