"use strict";(self.webpackChunkgeogardenclub_github_io=self.webpackChunkgeogardenclub_github_io||[]).push([[5002],{9516:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>d,contentTitle:()=>i,default:()=>l,frontMatter:()=>s,metadata:()=>r,toc:()=>h});var n=a(4848),o=a(8453);const s={hide_table_of_contents:!0},i="Database management",r={id:"develop/database-management",title:"Database management",description:"We use a Firebase database to store the entity data associated with GGC. (We use Google Cloud Storage to store the photos associated with GGC.)",source:"@site/docs/develop/database-management.md",sourceDirName:"develop",slug:"/develop/database-management",permalink:"/docs/develop/database-management",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{hide_table_of_contents:!0},sidebar:"developSidebar",previous:{title:"Cloud Storage Data Model",permalink:"/docs/develop/data-model/cloud-storage-data-model"},next:{title:"Deployment",permalink:"/docs/develop/deployment"}},d={},h=[{value:"1. Is the database consistent?",id:"1-is-the-database-consistent",level:2},{value:"2. How do we make the database consistent?",id:"2-how-do-we-make-the-database-consistent",level:2},{value:"2a. Updating Firebase: via the Console",id:"2a-updating-firebase-via-the-console",level:3},{value:"2b. Updating Firebase: via Database Operation",id:"2b-updating-firebase-via-database-operation",level:3},{value:"3. Is the database appropriate?",id:"3-is-the-database-appropriate",level:2}];function c(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",...(0,o.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.header,{children:(0,n.jsx)(t.h1,{id:"database-management",children:"Database management"})}),"\n",(0,n.jsx)(t.p,{children:"We use a Firebase database to store the entity data associated with GGC. (We use Google Cloud Storage to store the photos associated with GGC.)"}),"\n",(0,n.jsx)(t.p,{children:"There are three fundamental issues associated with the management of Firebase data:"}),"\n",(0,n.jsxs)(t.ol,{children:["\n",(0,n.jsx)(t.li,{children:'How do we determine if the database is in a "consistent" state?'}),"\n",(0,n.jsx)(t.li,{children:"If the database is in an inconsistent state, how do we update the database to get it back to a consistent state?"}),"\n",(0,n.jsx)(t.li,{children:'Is the database "appropriate", in that it supports storage and retrieval of information such that the needs of the customer are satisfied?'}),"\n"]}),"\n",(0,n.jsx)(t.h2,{id:"1-is-the-database-consistent",children:"1. Is the database consistent?"}),"\n",(0,n.jsx)(t.p,{children:'"Consistent" means that the data does not contain missing or incorrect values. This is not guaranteed by Firestore. For example, Firestore does not guarantee that a field that is supposed to contain a string representing a cropID actually contains a string that can be used to retrieve an existing Crop entity.'}),"\n",(0,n.jsxs)(t.p,{children:['Determination of database consistency (also known as "database integrity") is a quality assurance issue, which we address through the use of the ',(0,n.jsx)(t.a,{href:"/docs/develop/quality-assurance/integrity-check",children:"Database Integrity Check"})," mechanism."]}),"\n",(0,n.jsx)(t.h2,{id:"2-how-do-we-make-the-database-consistent",children:"2. How do we make the database consistent?"}),"\n",(0,n.jsx)(t.p,{children:"If the database is found to be inconsistent, then we need to update it to return it to a state of consistency.  We generally pick one of two approaches: (1) the Firebase console or (2) the Database Operation feature."}),"\n",(0,n.jsx)(t.h3,{id:"2a-updating-firebase-via-the-console",children:"2a. Updating Firebase: via the Console"}),"\n",(0,n.jsx)(t.p,{children:"If the inconsistency is minor and affects only a few documents, then a reasonable approach is to use the Firebase console:"}),"\n",(0,n.jsx)("img",{src:"/img/develop/firestore/firestore-console.png"}),"\n",(0,n.jsx)(t.p,{children:"The Firebase console enables you to edit, create, or delete any document, as well as search for documents satisfying a criteria."}),"\n",(0,n.jsx)(t.h3,{id:"2b-updating-firebase-via-database-operation",children:"2b. Updating Firebase: via Database Operation"}),"\n",(0,n.jsx)(t.p,{children:'Sometimes the inconsistency is not minor, and requires manipulation of dozens or hundreds of documents. This would be super painful to fix using the console.  For these situations, we\'ve developed an Admin command called "Database Operation". It allows you to programmatically inspect all documents in the database, decide what to create, modify, or delete, and then invoke the appropriate mutation.'}),"\n",(0,n.jsx)(t.p,{children:"To implement a programmatic update using Database Operation, you must first implement a subclass of DatabaseOperation. For example, here is a subclass that iterates through all observations and finds some that need to be updated:"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-dart",children:"class DatabaseOperation19 extends DatabaseOperation {\n  DatabaseOperation19(\n      {required super.chapters,\n      required super.gardens,\n      required super.users,\n      super.description =\n          'Fix all observations to refer to the \"Unknown\" variety, not the empty string'});\n\n  @override\n  void setup() {\n    List<Observation> observationsToSet = [];\n    for (Observation observation in chapters.observations.observations) {\n      if (!chapters.varieties.isVarietyID(observation.cachedVarietyID)) {\n        String cropID = observation.cachedCropID;\n        Variety unknownVariety =\n            chapters.crops.getUnknownVariety(chapters, cropID);\n        logger.d('Setting varietyID for  ${observation} to $unknownVariety');\n        Observation updatedObservation = observation.copyWith(\n          cachedVarietyName: unknownVariety.name,\n          cachedVarietyID: unknownVariety.varietyID,\n        );\n        observationsToSet.add(updatedObservation);\n      }\n    }\n\n    data.observationsToSet = observationsToSet;\n  }\n}\n"})}),"\n",(0,n.jsx)(t.p,{children:"When the simulator is run with this operation specified as the one to invoke in the DatabaseOperationScreen widget, then navigating to the Database Operation screen in the Admin panel might look like this:"}),"\n",(0,n.jsx)("img",{width:"500px",src:"/img/develop/firestore/db-operation.png"}),"\n",(0,n.jsx)(t.p,{children:"What's cool about the implementation of Database Operation is that when you navigate to the screen, it will tell you what it's going to do if you hit the \"Invoke Operation\" button. In this example, it will update 145 Observation documents."}),"\n",(0,n.jsx)(t.p,{children:'To do this, the setup() method is called when you visit the page, and its task is to figure out all the documents that need to be updated and then update the appropriate field in the "data" instance. This enables the page to provide feedback on how many entities of what type are going to be changed if you actually invoke the operation. (You can also use logger statements to get additional info on what the operation will do.)'}),"\n",(0,n.jsx)(t.h2,{id:"3-is-the-database-appropriate",children:"3. Is the database appropriate?"}),"\n",(0,n.jsx)(t.p,{children:"The answer is, more often than not, no.  Database evolution is a continuing part of system development and enhancement. So, we must often: (a) update our entity representations, (b) update our UI, (c) update our tests, and (d) use the Database Operation command to migrate the existing data to the new representation."})]})}function l(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(c,{...e})}):c(e)}},8453:(e,t,a)=>{a.d(t,{R:()=>i,x:()=>r});var n=a(6540);const o={},s=n.createContext(o);function i(e){const t=n.useContext(s);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:i(e.components),n.createElement(s.Provider,{value:t},e.children)}}}]);