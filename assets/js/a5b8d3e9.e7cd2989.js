"use strict";(self.webpackChunkgeogardenclub_github_io=self.webpackChunkgeogardenclub_github_io||[]).push([[6957],{6058:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>d,contentTitle:()=>i,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>c});var n=a(5893),r=a(1151);const o={hide_table_of_contents:!1},i="Data Mutation",s={id:"develop/design/data-mutation",title:"Data Mutation",description:"Prelude: AsyncValue",source:"@site/docs/develop/design/data-mutation.md",sourceDirName:"develop/design",slug:"/develop/design/data-mutation",permalink:"/docs/develop/design/data-mutation",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{hide_table_of_contents:!1},sidebar:"developSidebar",previous:{title:'"With" widgets',permalink:"/docs/develop/design/with-widgets"},next:{title:"Dart analyze",permalink:"/docs/develop/dart-analyze"}},d={},c=[{value:"Prelude: AsyncValue",id:"prelude-asyncvalue",level:2},{value:"Data mutation in GGC",id:"data-mutation-in-ggc",level:2},{value:"1. The data mutation widget",id:"1-the-data-mutation-widget",level:3},{value:"2. The onSubmit() method",id:"2-the-onsubmit-method",level:3},{value:"3. Mutate controller create, update, delete methods",id:"3-mutate-controller-create-update-delete-methods",level:3},{value:"4. Database methods",id:"4-database-methods",level:3},{value:"A template for the controller class",id:"a-template-for-the-controller-class",level:3}];function l(e){const t={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,r.a)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.header,{children:(0,n.jsx)(t.h1,{id:"data-mutation",children:"Data Mutation"})}),"\n",(0,n.jsx)(t.h2,{id:"prelude-asyncvalue",children:"Prelude: AsyncValue"}),"\n",(0,n.jsx)(t.p,{children:"When your code interacts with the database (or some other external service), you are generally in one of two situations:"}),"\n",(0,n.jsxs)(t.ol,{children:["\n",(0,n.jsxs)(t.li,{children:["Reading data: In this case, use a ",(0,n.jsx)(t.code,{children:"with"})," widget to retrieve the appropriate data for display, and separate the asynchronous code (to retrieve data from the database) from the synchronous code (to display it in the UI.)"]}),"\n",(0,n.jsx)(t.li,{children:"Writing data: In this case you must write asynchronous code to update the contents of the database."}),"\n"]}),"\n",(0,n.jsx)(t.p,{children:'The Flutterverse is filled with articles and example code on how to accomplish (2). For GGC, we will use the "Riverpod" design pattern, which involves:'}),"\n",(0,n.jsxs)(t.ol,{children:["\n",(0,n.jsxs)(t.li,{children:["Define a Riverpod provider (using the ",(0,n.jsx)(t.code,{children:"@riverpod"})," annotation) to perform the manipulation."]}),"\n",(0,n.jsx)(t.li,{children:"Handle the resulting AsyncValue's three possible states: loading, error, data."}),"\n"]}),"\n",(0,n.jsx)(t.p,{children:"Here are some useful readings to get you started:"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:(0,n.jsx)(t.a,{href:"https://courses.ics.hawaii.edu/mobile-application-development/morea/state/reading-eli5-riverpod.html",children:"Explain like I'm 5: Riverpod"})}),"\n",(0,n.jsx)(t.li,{children:(0,n.jsx)(t.a,{href:"https://codewithandrea.com/articles/flutter-riverpod-generator/",children:"How to autogenerate your providers with Flutter Riverpod Generator"})}),"\n",(0,n.jsx)(t.li,{children:(0,n.jsx)(t.a,{href:"https://codewithandrea.com/articles/data-mutations-riverpod/",children:"How to fetch data and perform data mutations with the Riverpod architecture"})}),"\n"]}),"\n",(0,n.jsx)(t.p,{children:"Now let's look at how we implement data mutation in GGC"}),"\n",(0,n.jsx)(t.h2,{id:"data-mutation-in-ggc",children:"Data mutation in GGC"}),"\n",(0,n.jsx)(t.p,{children:'In GGC, "data mutation" refers to creating, updating, and deleting entities from the database. In some cases, mutating one entity (i.e. deleting a Garden) requires the implicit mutation of many other entities (i.e. deleting the Garden\'s associated Beds, Plantings, Observations, Outcomes, and Tasks).'}),"\n",(0,n.jsxs)(t.p,{children:["Accomplishing a data mutation involves a complex interaction between the front-end user interface and the back-end database. There are many potential ways to accomplish this interaction, but we will follow a design pattern documented by Andrea Bizzotti in his various ",(0,n.jsx)(t.a,{href:"https://codewithandrea.com/",children:"Code With Andrea"})," tutorials, with some additional customizations to suit our own GGC architecture."]}),"\n",(0,n.jsxs)(t.p,{children:["The ",(0,n.jsx)(t.a,{href:"https://github.com/geogardenclub/ggc_app/blob/main/lib/features/garden/presentation/create_garden_screen.dart",children:"CreateGardenScreen"})," and  ",(0,n.jsx)(t.a,{href:"https://github.com/geogardenclub/ggc_app/blob/main/lib/features/garden/presentation/mutate_garden_controller.dart",children:"MutateGardenController"})," classes illustrate our data mutation design pattern."]}),"\n",(0,n.jsx)(t.p,{children:"Here is a walkthrough of some of the Garden code to illustrate the basic ideas of this design pattern."}),"\n",(0,n.jsx)(t.h3,{id:"1-the-data-mutation-widget",children:"1. The data mutation widget"}),"\n",(0,n.jsx)(t.p,{children:'A "Data mutation widget" (for example, UpdateGardenScreen) presents a user interface for performing a data mutation. The actual UI component displayed at any moment in time by the widget is determined by an associated controller (for example, MutateGardenController).  The controller indicates which of four UI components to present: (1) an initial UI component (typically a form), (2) a loading indicator UI component (while waiting for an asynchronous action to complete, (3) a "success" component (displayed if the asynchronous action completes successfully) or (4) an error UI component (displayed if the asynchronous completes with an error).'}),"\n",(0,n.jsx)(t.p,{children:"Here's an excerpt of UpdateGardenScreen illustrating the basic way in which the controller controls the UI state of the screen:"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-dart",metastring:'title="lib/features/garden/presentation/update_garden_screen.dart"',children:"  AsyncValue asyncUpdate = ref.watch(mutateGardenControllerProvider);\n  return Scaffold(\n    appBar: AppBar(\n      title: const Text('Update Garden'),\n      actions: [HelpButton(routeName: AppRoute.updateGarden.name)],\n    ),\n    body: asyncUpdate.when(\n        data: (_) => updateGardenForm(),\n        loading: () => const GgcLoadingIndicator(),\n        error: (e, st) => GgcError(e.toString(), st.toString())));\n}\n"})}),"\n",(0,n.jsx)(t.h3,{id:"2-the-onsubmit-method",children:"2. The onSubmit() method"}),"\n",(0,n.jsx)(t.p,{children:"If the initial UI component is a form, then it should have an async onSubmit() callback method. This method typically involves a sequence of three phases. The first phase checks that the form field values pass any validation criteria. If so, the second phase creates domain model entities as indicated by the form values. The third phase calls the appropriate mutate controller method, passing it the domain entities and an onSuccess() callback, which tells the controller which page to go to if the data mutation is successful."}),"\n",(0,n.jsx)(t.p,{children:"Here's an example:"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-dart",metastring:'title="lib/features/garden/presentation/edit_garden_screen.dart"',children:"   onSubmit() async {\n      // 1. Check that form fields are valid.\n      bool isValid = _formKey.currentState?.saveAndValidate() ?? false;\n      if (!isValid) return;\n      // 2. Create domain objects to send to controller.\n      String name = FieldKey.gardenTextField.currentState?.value;\n      List<dynamic> xFiles =\n          FieldKey.singleImagePicker.currentState?.value ?? [];\n      String editorsString =\n          FieldKey.editorsTextField.currentState?.value ?? '';\n      Garden garden = gardens.getGarden(gardenID);\n      List<String> updatedEditorUserIDs = users.parseUsernames(editorsString);\n      List<Editor> editorsToAdd = gardens.editors.makeNewEditors(\n          gardenID: gardenID,\n          chapterID: garden.chapterID,\n          gardenerIDs: updatedEditorUserIDs);\n      List<Editor> editorsToDelete = gardens.editors.getEditors(gardenID);\n      // Only update Editors collection if the field has changed.\n      if (gardens.editors.sameEditorList(editorsToAdd, editorsToDelete)) {\n        editorsToAdd = [];\n        editorsToDelete = [];\n      }\n      String profilePictureUrl = (xFiles.isNotEmpty && xFiles[0] is XFile)\n          ? await ImageStorage.cropAndUploadImage(\n              xFile: xFiles[0], entityID: gardenID, context: context)\n          : garden.profilePicture;\n      Garden updatedGarden = Garden(\n          gardenID: gardenID,\n          name: name,\n          profilePicture: profilePictureUrl,\n          chapterID: chapters.currentChapterID,\n          cropIDs: garden.cropIDs,\n          sharedSeedIDs: garden.sharedSeedIDs,\n          lastUpdate: DateTime.now(),\n          ownerID: users.currentUserID,\n          pictures: []);\n      // 3. Use controller to invoke updates on database.\n      ref.read(mutateGardenControllerProvider.notifier).updateGarden(\n            garden: updatedGarden,\n            editorsToAdd: editorsToAdd,\n            editorsToDelete: editorsToDelete,\n            onSuccess: () {\n              context.pop();\n              GlobalSnackBar.show('Garden \"$name\" updated.');\n            },\n          );\n    }\n"})}),"\n",(0,n.jsx)(t.admonition,{title:"Don't pass Collection classes to the controller method",type:"important",children:(0,n.jsxs)(t.p,{children:["To maintain separation of concerns, the values passed to mutate controller methods should be individual domain entities (i.e. ",(0,n.jsx)(t.code,{children:"Garden"}),", ",(0,n.jsx)(t.code,{children:"Editor"}),"), lists of domain entities (i.e. ",(0,n.jsx)(t.code,{children:"List<Garden>"}),", ",(0,n.jsx)(t.code,{children:"List<Editor>"}),"), or primitive types (",(0,n.jsx)(t.code,{children:"String"}),", ",(0,n.jsx)(t.code,{children:"int"}),", etc).  Don't pass collections (i.e. ",(0,n.jsx)(t.code,{children:"GardenCollection"}),", ",(0,n.jsx)(t.code,{children:"EditorCollection"}),").  Use these collection classes within the onSubmit() method to determine the domain entities to pass."]})}),"\n",(0,n.jsx)(t.h3,{id:"3-mutate-controller-create-update-delete-methods",children:"3. Mutate controller create, update, delete methods"}),"\n",(0,n.jsxs)(t.p,{children:["The Mutate Controller class typically implements create, update, and delete methods to handle the associated mutation.  These methods will often need to make multiple asynchronous calls to the backend database.  To do this efficiently, and also to provide atomicity, the controller should use the ",(0,n.jsx)(t.a,{href:"https://firebase.google.com/docs/firestore/manage-data/transactions#batched-writes",children:"Firestore batched write"})," facility."]}),"\n",(0,n.jsx)(t.p,{children:"Here is an example from MutateGardenController for creating a new Garden. Note that both the Garden and Editor databases are mutated:"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-dart",metastring:'title="lib/features/garden/presentation/mutate_garden_controller.dart"',children:" Future<void> createGarden({\n    required Garden garden,\n    required List<Editor> editors,\n    required VoidCallback onSuccess,\n  }) async {\n    state = const AsyncLoading();\n    AsyncValue nextState = const AsyncLoading();\n    GardenDatabase gardenDatabase = ref.watch(gardenDatabaseProvider);\n    EditorDatabase editorDatabase = ref.watch(editorDatabaseProvider);\n    final WriteBatch batch = FirebaseFirestore.instance.batch();\n    gardenDatabase.setGardenBatch(batch, garden);\n    editorDatabase.addEditorsBatch(batch, editors);\n    await batch\n        .commit()\n        .then((_) => nextState = const AsyncValue.data(null))\n        .catchError((e, st) => nextState = AsyncValue.error(e, st));\n    if (mounted) {\n      state = nextState;\n    }\n    if (!state.hasError) {\n      onSuccess();\n    }\n  }\n"})}),"\n",(0,n.jsxs)(t.p,{children:["Following the CodeWithAndrea guidelines, this method first sets the controller state to ",(0,n.jsx)(t.code,{children:"AsyncLoading"}),".  Then it gets the databases of interest, creates a ",(0,n.jsx)(t.code,{children:"batch"})," variable, and adds mutations to that batch variable by passing it into the appropriate methods in the variable database classes. Finally, it invokes the ",(0,n.jsx)(t.code,{children:"batch.commit()"})," method to do all of the mutations at once, and either sets the state to ",(0,n.jsx)(t.code,{children:"AsyncData()"})," if everything went well or ",(0,n.jsx)(t.code,{children:"AsyncError()"})," if a problem occurred. A nice feature of batched writes is that they are performed as a transaction---either all of the writes succeed, or none of them do."]}),"\n",(0,n.jsx)(t.h3,{id:"4-database-methods",children:"4. Database methods"}),"\n",(0,n.jsxs)(t.p,{children:["The final part of this coding standard involves the appropriate definition of database methods. As shown above, database methods should be written to accept a ",(0,n.jsx)(t.code,{children:"batch"})," parameter, and result in that parameter being updated with additional operations to perform. Here is an example:"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-dart",metastring:'title="lib/features/garden/data/editor_database.dart',children:" void createEditorsBatch(WriteBatch batch, List<Editor> editors) {\n    for (Editor editor in editors) {\n      _service.setDataBatch(\n          batch: batch,\n          path: FirestorePath.editor(editor.editorID),\n          data: editor.toJson());\n    }\n  }\n"})}),"\n",(0,n.jsx)(t.h3,{id:"a-template-for-the-controller-class",children:"A template for the controller class"}),"\n",(0,n.jsx)(t.p,{children:'There is some boilerplate code for controllers.  To make it a little easier to create new controllers, here is a template.  See the TODO comments for places where code needs to be added, and replace all occurrences of "TEMPLATE" by the entity being controller (i.e. Garden, User, Task, etc).'}),"\n",(0,n.jsx)(t.p,{children:'Note that we\'ll use "create" rather than "add" to conform to the CRUD acronym. This means that the associated screens should be changed from "AddX" to "CreateX".'}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-dart",children:"import 'package:cloud_firestore/cloud_firestore.dart';\nimport 'package:flutter/foundation.dart';\nimport 'package:riverpod_annotation/riverpod_annotation.dart';\n\npart 'mutate_TEMPLATE_controller.g.dart';\n\n@riverpod\nclass MutateTEMPLATEController extends _$MutateTEMPLATEController {\n  bool mounted = true;\n\n  @override\n  FutureOr<void> build() {\n    ref.onDispose(() => mounted = false);\n    state = const AsyncData(null);\n  }\n\n  Future<void> createTEMPLATE({\n    /// TODO: Pass in domain object here.\n    required VoidCallback onSuccess,\n  }) async {\n    state = const AsyncLoading();\n    AsyncValue nextState = const AsyncLoading();\n    // TODO: Watch the appropriate database instances here.\n    final WriteBatch batch = FirebaseFirestore.instance.batch();\n    // TODO: Invoke the database batch methods here.\n    await batch\n        .commit()\n        .then((_) => nextState = const AsyncValue.data(null))\n        .catchError((e, st) => nextState = AsyncValue.error(e, st));\n    if (mounted) {\n      state = nextState;\n    }\n    if (!state.hasError) {\n      onSuccess();\n    }\n  }\n\n\n  Future<void> updateTEMPLATE({\n    /// TODO: Pass in domain data here\n    required VoidCallback onSuccess,\n  }) async {\n    state = const AsyncLoading();\n    AsyncValue nextState = const AsyncLoading();\n    /// TODO: ref.watch the appropriate databases here.\n    final WriteBatch batch = FirebaseFirestore.instance.batch();\n    /// TODO: Invoke the appropriate database batch methods here.\n    await batch\n        .commit()\n        .then((_) => nextState = const AsyncValue.data(null))\n        .catchError((e, st) => nextState = AsyncValue.error(e, st));\n    if (mounted) {\n      state = nextState;\n    }\n    if (!state.hasError) {\n      onSuccess();\n    }\n  }\n  \n  Future<void> deleteTEMPLATE({\n    /// TODO: Pass in the appropriate domain objects here\n    required VoidCallback onSuccess,\n  }) async {\n    state = const AsyncLoading();\n    AsyncValue nextState = const AsyncLoading();\n    /// TODO: Watch the appropriate databases here.\n    final WriteBatch batch = FirebaseFirestore.instance.batch();\n    /// TODO: Invoke the appropriate database batch methods here.\n    await batch\n        .commit()\n        .then((_) => nextState = const AsyncValue.data(null))\n        .catchError((e, st) => nextState = AsyncValue.error(e, st));\n    if (mounted) {\n      state = nextState;\n    }\n    if (!state.hasError) {\n      onSuccess();\n    }\n  }\n}\n"})})]})}function h(e={}){const{wrapper:t}={...(0,r.a)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(l,{...e})}):l(e)}},1151:(e,t,a)=>{a.d(t,{Z:()=>s,a:()=>i});var n=a(7294);const r={},o=n.createContext(r);function i(e){const t=n.useContext(o);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function s(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),n.createElement(o.Provider,{value:t},e.children)}}}]);