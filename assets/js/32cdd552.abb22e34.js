"use strict";(self.webpackChunkgeogardenclub_github_io=self.webpackChunkgeogardenclub_github_io||[]).push([[6900],{8608:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>d,contentTitle:()=>s,default:()=>l,frontMatter:()=>o,metadata:()=>r,toc:()=>h});var n=a(5893),i=a(1151);const o={hide_table_of_contents:!0},s="Managing Firebase data",r={id:"develop/managing-firebase-data",title:"Managing Firebase data",description:"We use a Firebase database to store the data associated with GGC.  There are a couple of important issues associated with managing Firebase data.",source:"@site/docs/develop/managing-firebase-data.md",sourceDirName:"develop",slug:"/develop/managing-firebase-data",permalink:"/docs/develop/managing-firebase-data",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{hide_table_of_contents:!0},sidebar:"developSidebar",previous:{title:"Architecture",permalink:"/docs/develop/architecture"},next:{title:"Deployment",permalink:"/docs/develop/deployment"}},d={},h=[{value:"About database consistency",id:"about-database-consistency",level:2},{value:"Updating Firebase: via the Console",id:"updating-firebase-via-the-console",level:2},{value:"Updating Firebase: via Database Operation",id:"updating-firebase-via-database-operation",level:2}];function c(e){const t={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",...(0,i.a)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.header,{children:(0,n.jsx)(t.h1,{id:"managing-firebase-data",children:"Managing Firebase data"})}),"\n",(0,n.jsx)(t.p,{children:"We use a Firebase database to store the data associated with GGC.  There are a couple of important issues associated with managing Firebase data."}),"\n",(0,n.jsxs)(t.ol,{children:["\n",(0,n.jsx)(t.li,{children:'Is the database in a "consistent" state?'}),"\n",(0,n.jsx)(t.li,{children:"If the database is inconsistent, how do we restore the database to a consistent state?"}),"\n"]}),"\n",(0,n.jsx)(t.h2,{id:"about-database-consistency",children:"About database consistency"}),"\n",(0,n.jsx)(t.p,{children:'For a variety of reasons (mostly performance related), the data in the Firebase database is not  normalized. For example, certain documents will have a field starting with "cached" that indicates the document is holding data that was "derived" from other entities in the database. This is done to reduce the amount of data downloaded to each client app, and thus improve scalability of the system. Unfortunately, it is up to the app code to make sure these cached fields contain valid data.'}),"\n",(0,n.jsx)(t.p,{children:'In addition, our database structure includes many "foreign keys". For example, each Variety document has a field called "cropID", which holds a string that should contain the ID of the Crop entity associated with this Variety document.  In a SQL database, foreign keys can be managed automatically and the database can ensure that (a) any field that should contain a foreign key contains a valid foreign key, and (b) if you delete an entity, then any references to that entity\'s key (as a foreign key in some other record) will be deleted or dealt with appropriately. Unfortunately, in our NoSQL database, it is up to the app code to make sure that foreign keys are managed appropriately.'}),"\n",(0,n.jsx)(t.p,{children:'The presence of foreign keys and cached values that must be managed manually means, of course, that sometimes they aren\'t managed correctly because the code wasn\'t written right. To address this problem, we implemented an admin operation called "Integrity Check".  Associated with each entity in the system is an method that checks, to the best of our ability, the "integrity" of all documents of that type. The Integrity Check admin operation calls all of these individual integrity checks and reports if any violations are found. Here\'s the UI:'}),"\n",(0,n.jsx)("img",{width:"500px",src:"/img/develop/firestore/integrity-check.png"}),"\n",(0,n.jsx)(t.p,{children:"The good news is that if we implement the individual Integrity Check operations correctly (and that isn't very hard to do), then invoking this operation is pretty good at revealing whether the database is consistent with respect to foreign keys, caching, and any other properties of interest."}),"\n",(0,n.jsx)(t.p,{children:"The bad news is that we have to remember to invoke it."}),"\n",(0,n.jsx)(t.p,{children:"Good or bad, what this means is that we need to be able to (hopefully infrequently) update the Firestore database in order to restore it to a consistent state."}),"\n",(0,n.jsx)(t.h2,{id:"updating-firebase-via-the-console",children:"Updating Firebase: via the Console"}),"\n",(0,n.jsx)(t.p,{children:"If the inconsistency is minor and affects only a few documents, then a reasonable approach is to use the Firebase console:"}),"\n",(0,n.jsx)("img",{src:"/img/develop/firestore/firebase-console.png"}),"\n",(0,n.jsx)(t.p,{children:"The Firebase console enables you to edit, create, or delete any document, as well as search for documents satisfying a criteria."}),"\n",(0,n.jsx)(t.h2,{id:"updating-firebase-via-database-operation",children:"Updating Firebase: via Database Operation"}),"\n",(0,n.jsx)(t.p,{children:'Sometimes the inconsistency is not minor, and requires manipulation of dozens or hundreds of documents. This would be super painful to fix using the console.  For these situations, we\'ve developed an Admin command called "Database Operation". It allows you to programmatically inspect all documents in the database, decide what to create, modify, or delete, and then invoke the appropriate mutation.'}),"\n",(0,n.jsx)(t.p,{children:"To implement a programmatic update using Database Operation, you must first implement a subclass of DatabaseOperation. For example, here is a subclass that iterates through all observations and finds some that need to be updated:"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-dart",children:"class DatabaseOperation19 extends DatabaseOperation {\n  DatabaseOperation19(\n      {required super.chapters,\n      required super.gardens,\n      required super.users,\n      super.description =\n          'Fix all observations to refer to the \"Unknown\" variety, not the empty string'});\n\n  @override\n  void setup() {\n    List<Observation> observationsToSet = [];\n    for (Observation observation in chapters.observations.observations) {\n      if (!chapters.varieties.isVarietyID(observation.cachedVarietyID)) {\n        String cropID = observation.cachedCropID;\n        Variety unknownVariety =\n            chapters.crops.getUnknownVariety(chapters, cropID);\n        logger.d('Setting varietyID for  ${observation} to $unknownVariety');\n        Observation updatedObservation = observation.copyWith(\n          cachedVarietyName: unknownVariety.name,\n          cachedVarietyID: unknownVariety.varietyID,\n        );\n        observationsToSet.add(updatedObservation);\n      }\n    }\n\n    data.observationsToSet = observationsToSet;\n  }\n}\n"})}),"\n",(0,n.jsx)(t.p,{children:"When the simulator is run with this operation specified as the one to invoke in the DatabaseOperationScreen widget, then navigating to the Database Operation screen in the Admin panel might look like this:"}),"\n",(0,n.jsx)("img",{width:"500px",src:"/img/develop/firestore/db-operation.png"}),"\n",(0,n.jsx)(t.p,{children:"What's cool about the implementation of Database Operation is that when you navigate to the screen, it will tell you what it's going to do if you hit the \"Invoke Operation\" button. In this example, it will update 145 Observation documents."}),"\n",(0,n.jsx)(t.p,{children:'To do this, the setup() method is called when you visit the page, and its task is to figure out all the documents that need to be updated and then update the appropriate field in the "data" instance. This enables the page to provide feedback on how many entities of what type are going to be changed if you actually invoke the operation. (You can also use logger statements to get additional info on what the operation will do.)'})]})}function l(e={}){const{wrapper:t}={...(0,i.a)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(c,{...e})}):c(e)}},1151:(e,t,a)=>{a.d(t,{Z:()=>r,a:()=>s});var n=a(7294);const i={},o=n.createContext(i);function s(e){const t=n.useContext(o);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),n.createElement(o.Provider,{value:t},e.children)}}}]);