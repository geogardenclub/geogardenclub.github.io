"use strict";(self.webpackChunkgeogardenclub_github_io=self.webpackChunkgeogardenclub_github_io||[]).push([[8330],{722:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>s,default:()=>h,frontMatter:()=>o,metadata:()=>a,toc:()=>l});const a=JSON.parse('{"id":"develop/quality-assurance/coding-standards","title":"Coding Standards","description":"In GGC, quality assurance starts with coding standards, which are practices that reduce or avoid \\"technical debt\\".","source":"@site/docs/develop/quality-assurance/coding-standards.md","sourceDirName":"develop/quality-assurance","slug":"/develop/quality-assurance/coding-standards","permalink":"/docs/develop/quality-assurance/coding-standards","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"hide_table_of_contents":false},"sidebar":"developSidebar","previous":{"title":"Badges","permalink":"/docs/develop/design/badges"},"next":{"title":"Dart analyze","permalink":"/docs/develop/quality-assurance/dart-analyze"}}');var i=n(4848),r=n(8453);const o={hide_table_of_contents:!1},s="Coding Standards",d={},l=[{value:"Delete debugging/unused code",id:"delete-debuggingunused-code",level:2},{value:"Don&#39;t inline multi-statement callbacks",id:"dont-inline-multi-statement-callbacks",level:2},{value:"Don&#39;t inline form field definitions",id:"dont-inline-form-field-definitions",level:2},{value:"Avoid deep indentation",id:"avoid-deep-indentation",level:2},{value:"Don&#39;t write media-adaptive code",id:"dont-write-media-adaptive-code",level:2},{value:"Use named routes",id:"use-named-routes",level:2},{value:"Prefer widgets to helper methods",id:"prefer-widgets-to-helper-methods",level:2},{value:"Don&#39;t repeat titles",id:"dont-repeat-titles",level:2},{value:"Prefer late to dummy field values",id:"prefer-late-to-dummy-field-values",level:2},{value:"Case Study: Task Card",id:"case-study-task-card",level:2},{value:"The problem",id:"the-problem",level:3},{value:"One solution",id:"one-solution",level:3}];function c(e){const t={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"coding-standards",children:"Coding Standards"})}),"\n",(0,i.jsx)(t.p,{children:'In GGC, quality assurance starts with coding standards, which are practices that reduce or avoid "technical debt".'}),"\n",(0,i.jsx)(t.p,{children:"Technical debt refers to implementation practices that result in the need for refactoring of the code base at a future time."}),"\n",(0,i.jsx)(t.admonition,{title:"Coding standards apply to main branch only",type:"tip",children:(0,i.jsx)(t.p,{children:"The following standards apply only to code that you are about to merge into the main branch. You may want to violate these standards temporarily during initial development of a feature in your non-main branch.  That's OK."})}),"\n",(0,i.jsx)(t.h2,{id:"delete-debuggingunused-code",children:"Delete debugging/unused code"}),"\n",(0,i.jsx)(t.p,{children:"Often during development, you will insert debugging statements to help diagnose a problem. For example:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-dart",metastring:'title="home_screen_observations_view.dart"',children:" Widget build(BuildContext context) {\n    // logger.d('HomeScreenObservationsView.build $chapters');\n    // logger.d('HomeScreenObservationsView.build ${chapters.observations}');\n    // logger.d('HomeScreenObservationsView.build ${chapters.observations.size()}');\n    // logger.d('current user: ${users.currentUser}');\n    // logger.d('current gardener: ${gardens.gardeners.getGardener(users.currentUserID)}');\n    // List<String> chapterNames = chapters.getChapterNames();\n    List<Observation> observations = chapters.observations.getAllObservations();\n"})}),"\n",(0,i.jsx)(t.p,{children:"Or, you might try one way to implement a feature, but eventually decide upon another way. For example:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-dart",metastring:'title="home_screen_observations_view.dart"',children:"child: ListView(\n// children: observations\n//     .map((observation) => InstagramCard(\n//         observation: observation,\n//         chapterName: chapterNames[0],\n//         observations: chapters.observations,\n//         tags: chapters.tags,\n//         users: users))\n//     .toList()));\n  children: observations.map((observation) => ObservationCard(observation: observation, chapters: chapters, gardens: gardens, users: users)).toList()));\n"})}),"\n",(0,i.jsx)(t.p,{children:"Rather than comment out debugging or unused code, please delete it prior to merging into main. Deleting this code improves the signal-to-noise ratio for future readers. In the case of debugging statements, it is easy to re-insert them later if needed (and often, you will want to inspect different values later, so the commented lines aren't helpful)."}),"\n",(0,i.jsxs)(t.p,{children:["If you are concerned about deleting potentially valuable code, then feel free to copy the file into the ",(0,i.jsx)(t.code,{children:"graveyard/"})," directory prior to deleting the commented out code."]}),"\n",(0,i.jsx)(t.p,{children:"I can think of one possible exception to this rule: you are debating between two alternative implementations, and you want others to experiment by commenting out one alternative and then the other. But in all the cases I can think of, we have decided these kinds of issues via screen shots rather than code."}),"\n",(0,i.jsx)(t.h2,{id:"dont-inline-multi-statement-callbacks",children:"Don't inline multi-statement callbacks"}),"\n",(0,i.jsx)(t.p,{children:"We want to keep code modular and avoid deeply indented code. Deeply indented code is more difficult to read, and (because it's deeply indented) more cognitively demanding to understand."}),"\n",(0,i.jsx)(t.p,{children:"One good heuristic to avoid deeply indented code is to not inline multi-line callbacks.  For example, consider the following implementation of a PopupMenuButton:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-dart",metastring:'title="task_card.dart"',children:"                PopupMenuButton(\n                      initialValue: _selectedMenu,\n                      onSelected: (SampleItem result) {\n                        setState(() {\n                          _selectedMenu = result;\n                        });\n                        switch (result) {\n                          case SampleItem.editTask:\n                            context.pushNamed(AppRoute.editTask.name,\n                                pathParameters: {'taskID': widget.task.taskID});\n                            break;\n                          case SampleItem.gardenDetails:\n                            context.goNamed(AppRoute.gardenDetails.name,\n                                pathParameters: {\n                                  'gardenID': widget.task.gardenID\n                                });\n                            break;\n                        }\n                      },\n                      itemBuilder: (BuildContext context) => popupMenuItems),\n"})}),"\n",(0,i.jsx)(t.p,{children:"In this case, some of the code is indented 34 spaces, using up almost half of the allotted 80 character line width."}),"\n",(0,i.jsxs)(t.p,{children:["To avoid this situation, notice that the ",(0,i.jsx)(t.code,{children:"onSelected:"})," argument is an inline callback, which could be easily rewritten as a local function:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-dart",children:"void _onSelected(SampleItem result) {\n  setState(() => _selectedMenu = result);\n  switch (result) {\n    case SampleItem.editTask:\n      context.pushNamed(AppRoute.editTask.name,\n          pathParameters: {'taskID': widget.task.taskID});\n      break;\n    case SampleItem.gardenDetails:\n      context.goNamed(AppRoute.gardenDetails.name,\n          pathParameters: {'gardenID': widget.task.gardenID});\n      break;\n  }\n}\n"})}),"\n",(0,i.jsx)(t.p,{children:"And then provided as the callback value as follows:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-dart",children:"                  PopupMenuButton(\n                      initialValue: _selectedMenu,\n                      onSelected: _onSelected,\n                      itemBuilder: (BuildContext context) => popupMenuItems),\n"})}),"\n",(0,i.jsx)(t.p,{children:"This rewrite makes it easier to understand the PopupMenuButton invocation (because it is now only four lines long) as well as the onSelected callback (because it now has access to almost the full 80 character line width)."}),"\n",(0,i.jsxs)(t.p,{children:["This PopupMenuButton code snippet is also useful because it illustrates the situation in which inlining a callback is appropriate! This is when the callback is a one-liner, such as the argument to the ",(0,i.jsx)(t.code,{children:"itemBuilder:"})," parameter."]}),"\n",(0,i.jsx)(t.h2,{id:"dont-inline-form-field-definitions",children:"Don't inline form field definitions"}),"\n",(0,i.jsx)(t.p,{children:"Another situation that often leads to deeply indented code is when form field definitions are inline. For example, consider the first 30 lines of this call to FormBuilder:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-dart",metastring:'title="add_outcome_screen.dart"',children:"                       FormBuilder(\n                          child: Column(\n                          children: [\n                            Text('Outcome for $plantingName.',\n                                style: Theme.of(context).textTheme.titleLarge),\n                            const SizedBox(height: 5),\n                            const Text(\n                                'Please rate the following on a scale of 1 to 5, with 5 being the best.'),\n                            const SizedBox(height: 10),\n                            FormBuilderSlider(\n                              key: _germinationFieldKey,\n                              name: 'Germination',\n                              min: 1,\n                              max: 5,\n                              divisions: 4,\n                              decoration: ggcInputDecoration(\n                                  label: 'Germination',\n                                  required: true,\n                                  hintText: ''),\n                              initialValue: _germinationValue,\n                              valueTransformer: (value) {\n                                return value!.toInt();\n                              },\n                              onChanged: (value) {\n                                setState(() {\n                                  _germinationValue = value!;\n                                });\n                              },\n                            ),\n"})}),"\n",(0,i.jsx)(t.p,{children:"This is hard to read due to all the indentation, and it also has the potential to create very long form definitions. In this case, the complete call to FormBuilder is 200 lines long!"}),"\n",(0,i.jsxs)(t.p,{children:["To create more readable code, and also to create opportunities for reuse, define form fields as widgets in the ",(0,i.jsx)(t.code,{children:"lib/common/input-fields"})," directory.  For example, here is the definition for a text field that allows the user to name (or rename) their garden:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-dart",metastring:'title="garden_text_field.dart"',children:"class GardenTextField extends StatelessWidget {\n  const GardenTextField(\n      {super.key, required this.gardens, this.onTap, this.currName});\n\n  final GardenCollection gardens;\n  final void Function(String value)? onTap;\n  final String? currName;\n\n  @override\n  Widget build(BuildContext context) {\n    String fieldName = 'Garden Name';\n    return FieldPadding(\n      child: FormBuilderTextField(\n          name: fieldName,\n          key: FieldKey.gardenTextField,\n          decoration: ggcInputDecoration(\n            label: fieldName,\n            required: true,\n            hintText: '4-20 chars, alphanumeric/spaces, unique',\n          ),\n          initialValue: currName,\n          validator: FormBuilderValidators.compose([\n            GgcValidators.validName(),\n            GgcValidators.uniqueGardenName(gardens, currName)\n          ])),\n    );\n  }\n}\n"})}),"\n",(0,i.jsx)(t.p,{children:"Now you can use it in a call to FormBuilder, where the total number of lines in the definition will typically be only a few more than the total number of fields:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-dart",metastring:'title="add_garden_screen.dart"',children:"  FormBuilder(\n      key: _formKey,\n      child: Column(\n        children: [\n          GardenTextField(gardens: widget.gardens),\n          const SingleImagePicker(required: false),\n          EditorsTextField(users: widget.users),\n          FormButtons(onSubmit: onSubmit, onCancel: onCancel),\n        ],\n      ),\n    );\n"})}),"\n",(0,i.jsx)(t.p,{children:"As a bonus, GardenTextField is used in both the AddGarden form and the EditGarden Form, which avoids duplicate code."}),"\n",(0,i.jsxs)(t.p,{children:["Also note that the ",(0,i.jsx)(t.code,{children:"onSubmit:"})," and ",(0,i.jsx)(t.code,{children:"onCancel:"})," callbacks are not inlined, conforming to the prior coding standard."]}),"\n",(0,i.jsx)(t.h2,{id:"avoid-deep-indentation",children:"Avoid deep indentation"}),"\n",(0,i.jsx)(t.p,{children:"The prior two coding standards should significantly reduce the depth of indentation, but there may be other situations which result in deeply indented code."}),"\n",(0,i.jsx)(t.p,{children:"As a heuristic, if indentation exceeds 5 or 6 levels, think about creating local functions to encapsulate semantically meaningful units of functionality, and then invoking them instead of inlining all of the code."}),"\n",(0,i.jsx)(t.h2,{id:"dont-write-media-adaptive-code",children:"Don't write media-adaptive code"}),"\n",(0,i.jsx)(t.p,{children:"For the 1.0 release, we are not going to optimize layout for different screen sizes. So, please do not (for example) use MediaQuery to adjust values for different screen sizes. For example:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-dart",children:"double width = MediaQuery.of(context).size.width;\nif (!widget.readOnly) {\n  // compensate for the checkbox\n  width = width - 50;\n}\nif (width > 400) {\n  // horizontal mode so remove more.\n  width = width - 110;\n}\n"})}),"\n",(0,i.jsx)(t.p,{children:"The reason for this is to avoid: (a) investing time into writing code that we might abandon later once we decide on a comprehensive approach to screen-dependent layout, and (b) an inconsistent UI that is sometimes adaptive and sometimes not."}),"\n",(0,i.jsx)(t.p,{children:"For more information on this issue, see:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.a,{href:"https://docs.flutter.dev/ui/layout/responsive/adaptive-responsive",children:"Creating responsive and adaptive apps"})," provides an overview of the issue."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.a,{href:"https://www.youtube.com/watch?v=yytBENOnF0w",children:"Flutter Folio walkthrough"})," illustrates how a single app can provide different behaviors to support the strengths of different platforms."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.a,{href:"https://pub.dev/packages?q=responsive",children:'Search pub.dev for "responsive"'})," to see the many packages available to support responsive design."]}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"If you need to adjust the screen size for some other reason, that's OK."}),"\n",(0,i.jsx)(t.h2,{id:"use-named-routes",children:"Use named routes"}),"\n",(0,i.jsx)(t.p,{children:"Use named routing. For example, write this:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-dart",children:"onPressed: () =>\n  context.pushNamed(AppRoute.editObservation.name, pathParameters: {'observationID': widget.observation.observationID, 'gardenID': widget.observation.gardenID}),\n"})}),"\n",(0,i.jsx)(t.p,{children:"Not this:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-dart",children:"onPressed: () =>\n  context.push('/editObservation/${widget.observation.observationID}/${widget.observation.gardenID}');\n"})}),"\n",(0,i.jsx)(t.p,{children:"The reason is that if you change the path, you will have to change all the links to that path. If you use named routing, you only have to change the path in one place."}),"\n",(0,i.jsx)(t.h2,{id:"prefer-widgets-to-helper-methods",children:"Prefer widgets to helper methods"}),"\n",(0,i.jsx)(t.p,{children:'It is possible to create "helper" functions that return widgets, such as:'}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-dart",metastring:'title="lib/common/functions/make_fab.dart"',children:"FloatingActionButton makeFAB(String route, BuildContext context) {\n  return FloatingActionButton(\n    onPressed: () {\n      context.pushNamed(route);\n    },\n    child: const Icon(Icons.add),\n  );\n}\n\nFloatingActionButton makeFABWithParameters(\n    String route, Map<String, String> pathParameters, BuildContext context) {\n  return FloatingActionButton(\n    onPressed: () {\n      context.pushNamed(route, pathParameters: pathParameters);\n    },\n    child: const Icon(Icons.add),\n  );\n}\n"})}),"\n",(0,i.jsx)(t.p,{children:"There are several reasons why it is better to create widgets than helper methods, as is explained here:"}),"\n",(0,i.jsx)("iframe",{width:"100%",height:"415",src:"https://www.youtube.com/embed/IOyq-eTRhvo?si=arTUGsj7E-6iK0_Q",title:"YouTube video player",frameborder:"0",allow:"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share",allowfullscreen:!0}),"\n",(0,i.jsx)(t.p,{children:"In this case, here's what the stateless widget version would look like:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-dart",metastring:'title="lib/common/widgets/ggc_fab.dart"',children:"class GgcFAB extends StatelessWidget {\n  const GgcFAB(\n      {super.key, required this.route, this.pathParameters = const {}});\n\n  final String route;\n  final Map<String, String> pathParameters;\n\n  @override\n  Widget build(BuildContext context) {\n    return FloatingActionButton(\n      onPressed: () {\n        context.pushNamed(route, pathParameters: pathParameters);\n      },\n      child: const Icon(Icons.add),\n    );\n  }\n}\n"})}),"\n",(0,i.jsx)(t.p,{children:"The following code illustrates the very minimal differences in how they are called:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-dart",children:"  Widget? getFloatingActionButton(BuildContext context, int selectedIndex) {\n      if (selectedIndex == 0) {\n        return GgcFAB(route: AppRoute.createPlanting.name);\n      }\n      if (selectedIndex == 3) {\n        return makeFABWithParameters(AppRoute.createGardenTask.name,\n            {'gardenID': widget.gardenID}, context);\n      }\n      return null;\n    }\n"})}),"\n",(0,i.jsx)(t.p,{children:"It gets a little nicer if you convert to the stateless widget approach entirely, since you can tighten up the return type and remove the context argument:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-dart",children:"  GgcFAB? getFloatingActionButton(int selectedIndex) {\n      if (selectedIndex == 0) {\n        return GgcFAB(route: AppRoute.createPlanting.name);\n      }\n      if (selectedIndex == 3) {\n        return GgcFAB(route: AppRoute.createGardenTask.name,\n            pathParameters: {'gardenID': widget.gardenID});\n      }\n      return null;\n    }\n"})}),"\n",(0,i.jsx)(t.h2,{id:"dont-repeat-titles",children:"Don't repeat titles"}),"\n",(0,i.jsx)(t.p,{children:"The title should appear in the scaffold. It does not need to be repeated in the body:"}),"\n",(0,i.jsx)("img",{width:"300px",style:{borderStyle:"solid"},src:"/img/develop/coding-standards/repeated-title.png"}),"\n",(0,i.jsx)(t.h2,{id:"prefer-late-to-dummy-field-values",children:"Prefer late to dummy field values"}),"\n",(0,i.jsx)(t.p,{children:'Sometimes you need to create an entity that has required fields before you know what those fields are.  It is tempting to create a "dummy" entity with clearly incorrect values and then overwrite the fields once you know what the correct values are. For example, here\'s some code from TaskCard:'}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-dart",children:"    Planting updatedPlanting = Planting(\n        plantingID: 'plantingID',\n        chapterID: 'chapterID',\n        gardenID: 'gardenID',\n        cropID: 'cropID',\n        cropName: 'cropName',\n        lastUpdate: DateTime.now());\n    switch (task.taskType) {\n      case 'sow':\n        updatedPlanting = planting.copyWith(\n            startDate: completedDate, lastUpdate: DateTime.now());\n        break;\n      case 'transplant':\n        updatedPlanting = planting.copyWith(\n            transplantDate: completedDate, lastUpdate: DateTime.now());\n        break;\n      case 'firstHarvest':\n        updatedPlanting = planting.copyWith(\n            firstHarvestDate: completedDate, lastUpdate: DateTime.now());\n        break;\n      case 'endHarvest':\n        updatedPlanting = planting.copyWith(\n            endHarvestDate: completedDate, lastUpdate: DateTime.now());\n        break;\n      case 'pull':\n        updatedPlanting = planting.copyWith(\n            pullDate: completedDate, lastUpdate: DateTime.now());\n        break;\n      case 'other':\n        // TODO: implement other what do we do if they are finishing a non planting task?\n        break;\n    }\n"})}),"\n",(0,i.jsxs)(t.p,{children:["You can make the code shorter, and communicate your intent more clearly, by using the ",(0,i.jsx)(t.code,{children:"late"})," keyword:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-dart",children:"    late Planting updatedPlanting;\n    switch (task.taskType) {\n      case 'sow':\n        updatedPlanting = planting.copyWith(\n            startDate: completedDate, lastUpdate: DateTime.now());\n        break;\n      case 'transplant':\n        updatedPlanting = planting.copyWith(\n            transplantDate: completedDate, lastUpdate: DateTime.now());\n        break;\n      case 'firstHarvest':\n        updatedPlanting = planting.copyWith(\n            firstHarvestDate: completedDate, lastUpdate: DateTime.now());\n        break;\n      case 'endHarvest':\n        updatedPlanting = planting.copyWith(\n            endHarvestDate: completedDate, lastUpdate: DateTime.now());\n        break;\n      case 'pull':\n        updatedPlanting = planting.copyWith(\n            pullDate: completedDate, lastUpdate: DateTime.now());\n        break;\n      case 'other':\n        // TODO: implement other what do we do if they are finishing a non planting task?\n        break;\n    }\n"})}),"\n",(0,i.jsxs)(t.p,{children:["A more important reason to use ",(0,i.jsx)(t.code,{children:"late"})," is that if you fail to initialize the entity, you will get a runtime error that clearly indicates the problem, rather than a runtime error that initially seems unrelated (i.e. failure to find a chapterID)."]}),"\n",(0,i.jsx)(t.h2,{id:"case-study-task-card",children:"Case Study: Task Card"}),"\n",(0,i.jsx)(t.p,{children:"I've recently refactored the code for Task Cards and believe a short description of the experience could provide some insight into our current design and coding best practices."}),"\n",(0,i.jsx)(t.p,{children:"The GGC Task Card (at the time of writing) looked like this:"}),"\n",(0,i.jsx)("img",{width:"300px",style:{borderStyle:"solid"},src:"/img/develop/coding-standards/task-card.png"}),"\n",(0,i.jsx)(t.p,{children:'As you can see, the "description" is a little wordy. My initial goal was to simply change the implementation of this card so that the description would be more tabular in nature, provide the garden and bed names (if available) from the task document, and include the description field only in the case of "custom" tasks.'}),"\n",(0,i.jsx)(t.h3,{id:"the-problem",children:"The problem"}),"\n",(0,i.jsxs)(t.p,{children:["So, I went to ",(0,i.jsx)(t.code,{children:"task_card.dart"}),", and discovered this:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-dart",children:"import 'package:flutter/material.dart';\nimport 'package:go_router/go_router.dart';\nimport 'package:intl/intl.dart';\nimport 'package:jiffy/jiffy.dart';\n\nimport '../../../repositories/firestore/firestore_path.dart';\nimport '../../../repositories/firestore/firestore_service.dart';\nimport '../../../router.dart';\nimport '../../chapter/domain/chapter_collection.dart';\nimport '../../common/widgets/ggc_card.dart';\nimport '../../common/widgets/ggc_loading_indicator.dart';\nimport '../../garden/domain/garden_collection.dart';\nimport '../../global_snackbar.dart';\nimport '../../planting/domain/planting.dart';\nimport '../../user/domain/user_collection.dart';\nimport '../domain/task.dart';\n\nclass TaskCard extends StatefulWidget {\n  final Task task;\n  final ChapterCollection chapters;\n  final GardenCollection gardens;\n  final UserCollection users;\n  final bool readOnly;\n\n  const TaskCard(\n      {super.key,\n        required this.task,\n        required this.chapters,\n        required this.gardens,\n        required this.users,\n        required this.readOnly});\n\n  @override\n  State<TaskCard> createState() => _TaskCardState();\n}\n\nenum TaskCardAction { updateTask, deleteTask }\n\nclass _TaskCardState extends State<TaskCard> {\n  final _service = FirestoreService.instance;\n  bool _isWorking = false;\n  bool isChecked = false;\n  TaskCardAction? _selectedAction;\n\n  Future<Planting> getPlanting(String plantingID) {\n    return _service.fetchDocument(\n        path: FirestorePath.planting(plantingID),\n        builder: (data, documentId) => Planting.fromJson(data!));\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    DateTime now = DateTime.now();\n    bool late = widget.task.dueDate.isBefore(now);\n    final difference = widget.task.dueDate.difference(now);\n    final days = difference.inDays;\n    String dateStr = '';\n    if (days > 60) {\n      dateStr = DateFormat.yMd().format(widget.task.dueDate);\n    } else {\n      dateStr = Jiffy.parseFromDateTime(widget.task.dueDate).fromNow();\n    }\n    TextStyle? textStyle;\n    if (late) {\n      textStyle = TextStyle(\n        color: Theme.of(context).colorScheme.error,\n        // fontWeight: FontWeight.bold\n      );\n    }\n    double width = MediaQuery.of(context).size.width;\n    if (!widget.readOnly) {\n      // compensate for the checkbox\n      width = width - 50;\n    }\n    width = width - 120;\n    List<PopupMenuEntry<TaskCardAction>> popupMenuItems = [\n      const PopupMenuItem<TaskCardAction>(\n        value: TaskCardAction.updateTask,\n        child: Text('Update Task'),\n      ),\n      const PopupMenuItem(\n          value: TaskCardAction.deleteTask, child: Text('Delete Task'))\n    ];\n\n    return _isWorking\n        ? const GgcLoadingIndicator()\n        : GgcCard(\n      child: ListTile(\n        dense: false,\n        contentPadding: const EdgeInsets.symmetric(horizontal: 8.0),\n        horizontalTitleGap: 6,\n        //Code runs with this line commented out but theme isn't used.\n        //    tileColor: tileColor,\n        title: Row(\n          children: [\n            SizedBox(\n                width: width,\n                child: Text(widget.task.title,\n                    style: textStyle,\n                    softWrap: false,\n                    overflow: TextOverflow.ellipsis)),\n            const Spacer(),\n            PopupMenuButton(\n                initialValue: _selectedAction,\n                onSelected: (TaskCardAction result) {\n                  setState(() {\n                    _selectedAction = result;\n                  });\n                  switch (result) {\n                    case TaskCardAction.updateTask:\n                      context.pushNamed(AppRoute.taskUpdate.name,\n                          pathParameters: {\n                            'taskID': widget.task.taskID,\n                            'gardenID': widget.task.gardenID\n                          });\n                      break;\n                    case TaskCardAction.deleteTask:\n                      context.pushNamed(AppRoute.taskDelete.name,\n                          pathParameters: {\n                            'gardenID': widget.task.gardenID,\n                            'taskID': widget.task.taskID\n                          });\n                      break;\n                  }\n                },\n                itemBuilder: (BuildContext context) => popupMenuItems),\n          ],\n        ),\n        subtitle: Text('${widget.task.description} Due $dateStr',\n            style: textStyle),\n        isThreeLine: true,\n        leading: !widget.readOnly\n            ? Checkbox(\n          checkColor: Theme.of(context).primaryColor,\n          fillColor: MaterialStateProperty.resolveWith<Color?>(\n                  (Set<MaterialState> states) {\n                if (states.contains(MaterialState.pressed)) {\n                  return Theme.of(context)\n                      .primaryColor; // Color when checkbox is checked\n                }\n                return Colors\n                    .transparent; // Transparent fill color when checkbox is not checked\n              }),\n          value: isChecked,\n          onChanged: (bool? value) async {\n            if (value == true) {\n              DateTime? completedDate = await showDatePicker(\n                  context: context,\n                  helpText:\n                  'When did you complete ${widget.task.title}?',\n                  initialDate: widget.task.dueDate,\n                  firstDate: DateTime(2020),\n                  lastDate: DateTime((DateTime.now().year + 1)));\n              if (completedDate != null) {\n                setState(() {\n                  _isWorking = true;\n                });\n                updatePlanting(widget.task, completedDate)\n                    .then((_) => setState(() {\n                  _isWorking = false;\n                }));\n              }\n            }\n          },\n        )\n            : null,\n      ),\n    );\n  }\n\n  Future updatePlanting(Task task, DateTime completedDate) async {\n    String plantingID = widget.task.plantingID;\n    Planting planting = await getPlanting(plantingID);\n    late Planting updatedPlanting;\n    switch (task.taskType) {\n      case 'sow':\n        updatedPlanting = planting.copyWith(\n            startDate: completedDate, lastUpdate: DateTime.now());\n        break;\n      case 'transplant':\n        updatedPlanting = planting.copyWith(\n            transplantDate: completedDate, lastUpdate: DateTime.now());\n        break;\n      case 'firstHarvest':\n        updatedPlanting = planting.copyWith(\n            firstHarvestDate: completedDate, lastUpdate: DateTime.now());\n        break;\n      case 'endHarvest':\n        updatedPlanting = planting.copyWith(\n            endHarvestDate: completedDate, lastUpdate: DateTime.now());\n        break;\n      case 'pull':\n        updatedPlanting = planting.copyWith(\n            pullDate: completedDate, lastUpdate: DateTime.now());\n        break;\n      case 'other':\n      // TODO: implement other what do we do if they are finishing a non planting task?\n        break;\n    }\n    // update the planting if completed\n    if (updatedPlanting.plantingID != 'plantingID') {\n      _service\n          .setData(\n          path: FirestorePath.planting(updatedPlanting.plantingID),\n          data: updatedPlanting.toJson())\n          .then((val) => GlobalSnackBar.show('Planting update succeeded.'))\n          .catchError((e) =>\n          GlobalSnackBar.show('Planting update failed\\n${e.toString()}.'));\n    }\n    // remove the task\n    deleteTask(task);\n  }\n\n  Future deleteTask(Task task) async {\n    _service\n        .deleteData(path: FirestorePath.task(task.taskID))\n        .then((val) => GlobalSnackBar.show('Task delete succeeded.'))\n        .catchError(\n            (e) => GlobalSnackBar.show('Task delete failed\\n${e.toString()}.'));\n  }\n}\n"})}),"\n",(0,i.jsxs)(t.p,{children:["Here are a few of the things I noticed about ",(0,i.jsx)(t.code,{children:"task_card.dart"}),":"]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"It is over 200 LOC. Generally, our top-level Card implementations are around 50 LOC. This is a red flag."}),"\n",(0,i.jsx)(t.li,{children:'The implementation is what I would call "flat", or "inline". In other words, there is no modularization of the TaskCard UI components. You can see this by looking at the import statements: there is not a single import of a widget in the same directory.'}),"\n",(0,i.jsx)(t.li,{children:"The code to implement the popup menu is approximately 35 LOC, but is scattered across 100 LOC."}),"\n",(0,i.jsx)(t.li,{children:'The implementation of a UI component (TaskCard) includes code making asynchronous database calls. Our current best practice calls for the use of "mutator controllers" to bridge between UI components and the backend database.'}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"These issues make understanding this single file of code difficult. For example:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"How and where should I change to code to conditionally format the description field based on task type?"}),"\n",(0,i.jsxs)(t.li,{children:["What are the functions of the ",(0,i.jsx)(t.code,{children:"_isWorking"}),", ",(0,i.jsx)(t.code,{children:"_isChecked"}),", and ",(0,i.jsx)(t.code,{children:"_selectedAction"})," state variables?"]}),"\n",(0,i.jsx)(t.li,{children:'Changes or enhancements following this "inline" design will make this code even more complicated. At some point, it will become very difficult to understand and maintain.'}),"\n"]}),"\n",(0,i.jsx)(t.h3,{id:"one-solution",children:"One solution"}),"\n",(0,i.jsx)(t.p,{children:"There are two simple design patterns that I used to modularize and simplify the code so that I could implement my table-based description enhancement."}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"I made each visible UI component into its own widget."}),' Looking at the TaskCard, an obvious top-level decomposition is into two Widgets: a "Title" widget and a "Description" widget. The "Title" widget can be further decomposed into three widgets: a "Checkbox", "Title", and "PopUp Menu".  The following annotated screenshot of the TaskCard illustrates this breakdown with the top-level decomposition in red and the nested decomposition in green:']}),"\n",(0,i.jsx)("img",{width:"300px",style:{borderStyle:"solid"},src:"/img/develop/coding-standards/task-card-widgets.png"}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"I used the mutator controller design pattern to move the database access code out of the UI component and into the controller."}),"  Interestingly, this not only made the DB access code more simple, it even made it a bit more efficient because multiple collections needed updates and the mutator controller supports batch updates."]}),"\n",(0,i.jsxs)(t.p,{children:["After implementing these changes, ",(0,i.jsx)(t.code,{children:"task_card.dart"})," now looks like this:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-dart",children:"import 'package:flutter/material.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\n\nimport '../../chapter/domain/chapter_collection.dart';\nimport '../../common/widgets/ggc_card.dart';\nimport '../../common/widgets/ggc_error.dart';\nimport '../../common/widgets/ggc_loading_indicator.dart';\nimport '../../garden/domain/garden_collection.dart';\nimport '../../global_snackbar.dart';\nimport '../../user/domain/user_collection.dart';\nimport '../domain/task.dart';\nimport 'mutate_task_controller.dart';\nimport 'task_card_description.dart';\nimport 'task_card_title_row.dart';\n\ntypedef OnCompletedCallback = void Function(Task task, DateTime completedDate);\n\nclass TaskCard extends ConsumerWidget {\n  final Task task;\n  final ChapterCollection chapters;\n  final GardenCollection gardens;\n  final UserCollection users;\n  final bool readOnly;\n\n  const TaskCard(\n      {super.key,\n      required this.task,\n      required this.chapters,\n      required this.gardens,\n      required this.users,\n      required this.readOnly});\n\n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    void onCompleted(Task task, DateTime completedDate) {\n      ref.read(mutateTaskControllerProvider.notifier).completeTask(\n          task: task,\n          completedDate: completedDate,\n          onSuccess: () {\n            GlobalSnackBar.show('Task completed.');\n          });\n    }\n\n    AsyncValue asyncUpdate = ref.watch(mutateTaskControllerProvider);\n    return asyncUpdate.when(\n        data: (_) => GgcCard(\n                child: Column(children: [\n                                TaskCardTitleRow(task: task, onCompleted: onCompleted),\n                                TaskCardDescription(task: task),\n            ])),\n        loading: () => const GgcLoadingIndicator(),\n        error: (e, st) => GgcError(e.toString(), st.toString()));\n  }\n}\n"})}),"\n",(0,i.jsx)(t.p,{children:"Let's see how the problems with the original implementation have been addressed."}),"\n",(0,i.jsxs)(t.p,{children:["First, the size of ",(0,i.jsx)(t.code,{children:"task_card.dart"}),' is now around 50 lines of code, back to a typical size for a GGC "Card" UI component.']}),"\n",(0,i.jsx)(t.p,{children:"Second, the UI code is modularized into five widgets: TaskCard, TaskCardTitleRow, TaskCardDescription, TaskCardCheckbox, and TaskCardPopupMenu."}),"\n",(0,i.jsx)(t.p,{children:"Third, the code to implement the PopupMenu is now encapsulated within a single widget. Interestingly, this refactoring revealed that there is a popup menu in ObservationCard with a very similar structure!  It would be straight forward to do an additional refactoring to create a single generic popup menu (for example, GgcPopupMenu) that can be used anywhere we need one."}),"\n",(0,i.jsx)(t.p,{children:"Fourth, as already noted, the asynchronous DB access code is now entirely encapsulated within the completeTask method of the mutator. The completeTask method is 25 LOC, while the original inline approach required approximately 60 LOC. That is a significant simplification."}),"\n",(0,i.jsx)(t.p,{children:"Finally, here's what my new version of TaskCard looks like:"}),"\n",(0,i.jsx)("img",{width:"300px",style:{borderStyle:"solid"},src:"/img/develop/coding-standards/tasks-revised.png"}),"\n",(0,i.jsx)(t.p,{children:'The top and bottom tasks are "implicit" tasks (based on Planting dates), while the middle task is an "explicit" task (defined by the gardener.)'}),"\n",(0,i.jsx)(t.p,{children:'No code is ever "perfect" or "complete". I am sure that there are more improvements to be made to TaskCard. But I hope this case study helps improve our collective intuition about how to design and implement Flutter code.'})]})}function h(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>s});var a=n(6540);const i={},r=a.createContext(i);function o(e){const t=a.useContext(r);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function s(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),a.createElement(r.Provider,{value:t},e.children)}}}]);