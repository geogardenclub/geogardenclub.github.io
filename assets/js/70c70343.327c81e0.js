"use strict";(self.webpackChunkgeogardenclub_github_io=self.webpackChunkgeogardenclub_github_io||[]).push([[9728],{8216:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"develop/design/ids","title":"ID management","description":"In NoSQL databases, it is common for each document to be automatically provided upon creation with a unique string called a \\"docID\\" which looks something like this: tghHU4CVfxHGB. The docID is generated by the server and is guaranteed to be unique. It serves as the primary key for entities in that collection.","source":"@site/docs/develop/design/ids.md","sourceDirName":"develop/design","slug":"/develop/design/ids","permalink":"/docs/develop/design/ids","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"hide_table_of_contents":false},"sidebar":"developSidebar","previous":{"title":"Features","permalink":"/docs/develop/design/features"},"next":{"title":"Input Management","permalink":"/docs/develop/design/input-management"}}');var a=n(4848),s=n(8453);const r={hide_table_of_contents:!1},o="ID management",c={},l=[];function d(e){const t={a:"a",code:"code",h1:"h1",header:"header",li:"li",p:"p",ul:"ul",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.header,{children:(0,a.jsx)(t.h1,{id:"id-management",children:"ID management"})}),"\n",(0,a.jsxs)(t.p,{children:['In NoSQL databases, it is common for each document to be automatically provided upon creation with a unique string called a "docID" which looks something like this: ',(0,a.jsx)(t.code,{children:"tghHU4CVfxHGB"}),". The docID is generated by the server and is guaranteed to be unique. It serves as the primary key for entities in that collection."]}),"\n",(0,a.jsx)(t.p,{children:'In GGC, we use a different approach. There is no "docID" field. Instead, the Crop collection has a unique ID called "cropID", the Chapter collection has a unique ID called "chapterID", and so forth. We tell the NoSQL database (in our case, Firebase) that these various ID fields should be used as the primary key (i.e. the docID) for each of the collections.'}),"\n",(0,a.jsx)(t.p,{children:"Importantly, non-global entities are generally created by users, and so in GGC, the client app (not the database server) is responsible for generating the primary keys for these entities."}),"\n",(0,a.jsx)(t.p,{children:"We have the client app generate the primary keys for non-global entities for the following reasons:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:'Rather than a server-generated random string, our client-generated primary keys are "human-readable". You can look at an ID string and know what kind of entity it is associated with (all GGC IDs have a prefix like "chapter-", "crop-", etc). Since many entities have fields containing the IDs of other entities, human-readable IDs help in development and system understanding.'}),"\n",(0,a.jsx)(t.li,{children:"In many cases, an update to the database can involve the creation of a new entity (or entities) as well as updates to other entities to include the primary key of the newly created entity (or entities). If primary keys are generated by the server, such updates would become a complex, multi-step process. Since primary keys are generated by the client, these updates are much more simple to accomplish."}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"However, client-generated primary keys have one significant risk:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:'It becomes technically possible for GGC to have a "primary key collision", i.e. an attempt by two different clients to create two entities with the same primary key value at the same time.'}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"To deal with this risk, we have carefully designed the primary keys in GGC to make it extremely unlikely for primary key collisions to occur."}),"\n",(0,a.jsx)(t.p,{children:"First, primary keys are constructed to include one or more of the chapterID, the country code, the postal code, or the gardenID. This means, for example, that rather than it being possible for a primary key collision to occur by any two GGC users anywhere in the world, it is becomes only possible for it to occur between the owner and editors of a single garden."}),"\n",(0,a.jsx)(t.p,{children:'Second, client-generated primary keys are constructed with a "millis" field. This is a four digit number representing the millisecond value at the time the client created the primary key.'}),"\n",(0,a.jsx)(t.p,{children:"We believe that these two properties of primary keys mean that collisions will not occur in practice, even when clients are operating in disconnected mode."}),"\n",(0,a.jsx)(t.p,{children:"Finally, let's say that this exceedingly unlikely event actually occurs.  In that case, because we have told Firebase that the plantingID (for example) is the primary key, Firebase will reject the second plantingID creation. In this case, the application can simply report the error and instruct the user to try again in a few seconds. By this time, the local cache should be updated and the request to create the new entity should succeed."}),"\n",(0,a.jsxs)(t.p,{children:["Note that ",(0,a.jsx)(t.a,{href:"https://firebase.google.com/docs/firestore/best-practices#hotspots",children:"Firebase recommends against creating documentIDs with lexicographically close ranges"}),". We hope that the inclusion of the millis field mitigates this potential performance issue."]})]})}function h(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>o});var i=n(6540);const a={},s=i.createContext(a);function r(e){const t=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),i.createElement(s.Provider,{value:t},e.children)}}}]);