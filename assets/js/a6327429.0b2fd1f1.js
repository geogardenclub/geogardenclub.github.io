"use strict";(self.webpackChunkgeogardenclub_github_io=self.webpackChunkgeogardenclub_github_io||[]).push([[9747],{1259:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>h,frontMatter:()=>s,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"develop/design/features","title":"Features","description":"The GGC app loosely follows the \\"feature first\\" design philosophy expressed in Andrea Bizzotto\'s article Flutter Project Structure","source":"@site/docs/develop/design/features.md","sourceDirName":"develop/design","slug":"/develop/design/features","permalink":"/docs/develop/design/features","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"hide_table_of_contents":false},"sidebar":"developSidebar","previous":{"title":"Firebase Billing","permalink":"/docs/develop/firebase-billing"},"next":{"title":"ID management","permalink":"/docs/develop/design/ids"}}');var a=n(4848),o=n(8453);const s={hide_table_of_contents:!1},i="Features",c={},d=[];function l(e){const t={a:"a",admonition:"admonition",code:"code",h1:"h1",header:"header",p:"p",pre:"pre",...(0,o.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.header,{children:(0,a.jsx)(t.h1,{id:"features",children:"Features"})}),"\n",(0,a.jsxs)(t.p,{children:['The GGC app loosely follows the "feature first" design philosophy expressed in Andrea Bizzotto\'s article ',(0,a.jsx)(t.a,{href:"https://codewithandrea.com/articles/flutter-project-structure/",children:"Flutter Project Structure: Feature-first or Layer-first?"}),". As noted in ",(0,a.jsx)(t.a,{href:"/docs/develop/architecture",children:"Architecture"}),", the top-level ",(0,a.jsx)(t.code,{children:"lib/"})," directory contains a ",(0,a.jsx)(t.code,{children:"features"})," subdirectory. Let's look at a snapshot of its contents:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-shell",children:"~/GitHub/geogardenclub/ggc_app/lib/features git:[main] ls\nadmin/          bed/          common/       garden/       help/          outcome/       tag/           variety/\nauthentication/ chapter/      crop/         gardener/     home/          planting/      task/\nbadge/          chat/         family/       geobot/       observation/   settings/      user/\n"})}),"\n",(0,a.jsxs)(t.p,{children:["As you can see, the ",(0,a.jsx)(t.code,{children:"features/"}),' directory consists of a couple dozen subdirectories, each of which contains the implementation of a "feature". In many cases, a feature is an entity in the data model (i.e. Bed, Garden, Planting, etc.). In other cases, a feature is a conceptually coherent mechanism (i.e. authentication, help). Then there\'s the ',(0,a.jsx)(t.code,{children:"common/"})," directory, which isn't actually a feature at all, but which holds cross-cutting functionality that is used by multiple features, and which seems most appropriate to be located in this subdirectory even though it isn't actually a feature."]}),"\n",(0,a.jsx)(t.admonition,{title:"Tests are also organized by feature",type:"info",children:(0,a.jsxs)(t.p,{children:["Fun fact: if you look in the ",(0,a.jsx)(t.code,{children:"integration_test/features"})," directory, you'll see a set of subdirectories that almost directly correspond to the subdirectories in ",(0,a.jsx)(t.code,{children:"lib/features"}),"."]})}),"\n",(0,a.jsxs)(t.p,{children:['A distinguishing characteristic of a GGC feature is that it is implemented in terms of one or more of the following components: "data", "domain", and "presentation". As a result, if you look into a feature directory, you will find one or more of the following subdirectories: ',(0,a.jsx)(t.code,{children:"data/"}),", ",(0,a.jsx)(t.code,{children:"domain/"}),", and ",(0,a.jsx)(t.code,{children:"presentation/"}),'.  Here\'s the contents of those directories for a relatively simple feature: "Crop":']}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-shell",children:"crop/\n  data/\n    crop_database.dart \n    crop_provider.dart              \n    crop_provider.g.dart            \n    fixture_crop_database.dart\n  domain/\n    crop.dart               \n    crop.freezed.dart       \n    crop.g.dart             \n    crop_collection.dart\n  presentation/\n    create_crop_screen.dart         \n    crop_chip.dart                  \n    crop_delete_button.dart         \n    crop_form.dart                  \n    crop_index_screen.dart          \n    crop_toggle_section.dart        \n    crop_view.dart                  \n    crop_view_screen.dart\n    delete_crop_screen.dart\n    update_crop_screen.dart\n"})}),"\n",(0,a.jsxs)(t.p,{children:["The ",(0,a.jsx)(t.code,{children:"data/"})," directory contains code that provides the mechanisms for persisting data associated with this feature to Firebase. It also includes the Riverpod Providers for accessing this data from elsewhere in the app. Finally, it includes the code for overriding the normal Firebase connection and replacing it with a connection to test fixture data. Note that at the ",(0,a.jsx)(t.code,{children:"data/"})," level, data is represented as JSON."]}),"\n",(0,a.jsxs)(t.p,{children:["The ",(0,a.jsx)(t.code,{children:"domain/"})," directory contains class definitions (along with the ",(0,a.jsx)(t.a,{href:"https://pub.dev/packages/freezed",children:"Freezed"})," enhancements) to represent the feature data as instances of a Dart class, not JSON.  In addition, the ",(0,a.jsx)(t.code,{children:"domain/"}),' directory can contain a "Collection" class. This is a class that aggregates together all the individual instances of the feature and provides operations (such as find or filter) to manipulate the entire population of feature instances.']}),"\n",(0,a.jsxs)(t.p,{children:["The ",(0,a.jsx)(t.code,{children:"presentation/"}),' directory contains UI code. "Top-level" UI classes (containing a Scaffold) are called "screens", and there is a special kind of screen called an "index screen" which provides a way to present all the instances of a feature and search, sort, or filter them.  Other common UI classes are "views" (which are reusable components within a screen), "forms" (containing one or more input controllers to gather information from the user), "chips" (presenting a clickable tile representing a feature instance), and "buttons". To support mutation of the feature, there can be "create", "update", and "delete"  screens.']}),"\n",(0,a.jsxs)(t.p,{children:['Not all features will have all three of these subdirectories. For example, the "home" feature contains only a ',(0,a.jsx)(t.code,{children:"presentation/"})," subdirectory, because this feature only manipulates entities defined as part of other features."]})]})}function h(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(l,{...e})}):l(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>s,x:()=>i});var r=n(6540);const a={},o=r.createContext(a);function s(e){const t=r.useContext(o);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),r.createElement(o.Provider,{value:t},e.children)}}}]);