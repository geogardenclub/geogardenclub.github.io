"use strict";(self.webpackChunkgeogardenclub_github_io=self.webpackChunkgeogardenclub_github_io||[]).push([[7346],{3098:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>c,contentTitle:()=>s,default:()=>h,frontMatter:()=>a,metadata:()=>o,toc:()=>l});var n=r(5893),i=r(1151);const a={hide_table_of_contents:!1},s="Architecture",o={id:"develop/architecture",title:"Architecture",description:'The GeoGardenClub app (GGC) conforms (most of the time) to the architectural approach advocated by Andreas Bizzotto which he calls the "Riverpod Architecture".  If you are not familiar with this approach, it\'s worth spending a few minutes reading through his description, which is available as a set of readings in the architecture module in my mobile application development course.',source:"@site/docs/develop/architecture.md",sourceDirName:"develop",slug:"/develop/architecture",permalink:"/docs/develop/architecture",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{hide_table_of_contents:!1},sidebar:"developSidebar",previous:{title:"Coding Standards",permalink:"/docs/develop/coding-standards"},next:{title:"Deployment",permalink:"/docs/develop/deployment"}},c={},l=[{value:"Client-server architecture perspective",id:"client-server-architecture-perspective",level:2},{value:"Layered application architecture perspective",id:"layered-application-architecture-perspective",level:2},{value:"Directory structure perspective",id:"directory-structure-perspective",level:2}];function d(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",p:"p",pre:"pre",strong:"strong",...(0,i.a)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.h1,{id:"architecture",children:"Architecture"}),"\n",(0,n.jsxs)(t.p,{children:['The GeoGardenClub app (GGC) conforms (most of the time) to the architectural approach advocated by Andreas Bizzotto which he calls the "Riverpod Architecture".  If you are not familiar with this approach, it\'s worth spending a few minutes reading through his description, which is available as a set of readings in the ',(0,n.jsx)(t.a,{href:"https://courses.ics.hawaii.edu/mobile-application-development/modules/architecture/",children:"architecture module"})," in my mobile application development course."]}),"\n",(0,n.jsx)(t.h2,{id:"client-server-architecture-perspective",children:"Client-server architecture perspective"}),"\n",(0,n.jsxs)(t.p,{children:["To begin, GGC can be viewed as a simple client-server application: there is a central back-end server (in our case, ",(0,n.jsx)(t.a,{href:"https://firebase.google.com/docs/firestore",children:"Firestore"}),") that communicates with front-end clients (in our case, the Flutter ggc_app application):"]}),"\n",(0,n.jsx)("img",{src:"/img/develop/release-1.0/ggc-architecture.png"}),"\n",(0,n.jsx)(t.h2,{id:"layered-application-architecture-perspective",children:"Layered application architecture perspective"}),"\n",(0,n.jsx)(t.p,{children:"In the above diagram, the client app is structured as four layers. This layering is strict, in that each layer communicates only with the layer above and below it."}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.strong,{children:"Repository Layer"}),". This bottom-most layer implements generic code for communication with Firebase: querying collections for documents; adding, deleting, and modifying documents, and so forth. In this layer, data is represented in JSON format (for entities) or binary format (for images)."]}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.strong,{children:"Data Layer"}),'.  The data layer implements "feature-specific" communication with Firebase. For example, the Data Layer code for the Chapter feature implements classes that queries the Chapter collection in appropriate ways. In this layer, data is still represented as JSON or binary.']}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.strong,{children:"Domain Layer"}),'. The domain layer implements code to translate between the data representations used at the data layer (i.e. JSON and Binary) and the data representations used at the Presentation Layer (i.e. Dart classes for entities and collections). The domain layer also implements the "business logic" of the application as discussed in the ',(0,n.jsx)(t.a,{href:"/docs/develop/design/data-model#collections-and-business-logic",children:"Collections and business logic"})," section."]}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.strong,{children:"Presentation Layer"}),'. The presentation layer implements the Flutter-based user interface.  All of the classes at the presentation layer are Widgets. GGC divides UI classes into two types: "Screens" and "Views".  Screens implement a "top-level" page: they return a Scaffold Widget and can be routed to.  Views are "components": they are the building blocks for Screens and can potentially appear in multiple Screens.']}),"\n",(0,n.jsx)(t.h2,{id:"directory-structure-perspective",children:"Directory structure perspective"}),"\n",(0,n.jsx)(t.p,{children:"There is a relatively straightforward correspondence between the above layers and the directory structure in the ggc_app repository. The top-level of the repo is more or less like any Flutter app.  Here is a semi-annotated version of most of the top-level files and directories:"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{children:"ggc_app/\n  .github/                  # CI GitHub Actions\n  android/\n  assets/\n  ios/\n  lib/                      # Source code here\n  linux/\n  macos/\n  stories/                  # Monarch stories here.\n  test/\n  web/\n  windows/\n  analysis_options.yaml\n  build_runner.sh           # Useful if you change data model.\n  lakos.sh                  # Build a diagram of the architecture\n  pubspec.yaml\n  run_monarch.sh            # Run the Monarch UI Story system\n"})}),"\n",(0,n.jsx)(t.p,{children:"The lib/ directory is where most of the action is. Here's a semi-annotated perspective of some the top-level of the lib/ directory:"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{children:'lib/\n  features/        #  Feature-based organization for Data, Domain, and Presentation layers\n  repositories/    #  Implements the "Repository" layer\n  main.dart        #  Main entry point\n  router.dart      #  Implements routes using go_router \n  theme_data.dart  #  Implements a theme using FlexColorScheme\n'})}),"\n",(0,n.jsx)(t.p,{children:"Finally, here's a look inside the features/ directory:"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{children:"features/\n  authentication/        # Authentication using firebase_ui_auth.\n    /presentation        # Implementation only requires UI widgets.\n    \n  common/                # Cross-cutting code\n  \n  chapter/               # Implementation of Chapter feature\n    data/                # Firebase interface\n    domain/              # Chapter, ChapterCollection, etc.\n    presentation/        # ChapterIndexScreen, ChapterView, etc.\n    \n  crop/\n  garden/\n  gardener/\n  home/\n  observation/\n  :\n  :\n"})}),"\n",(0,n.jsx)(t.p,{children:"Each feature can have one or more of the following subdirectories: domain/, data/, and presentation/.  The authentication feature only requires a presentation/ subdirectory, while the chapter feature requires all three."})]})}function h(e={}){const{wrapper:t}={...(0,i.a)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(d,{...e})}):d(e)}},1151:(e,t,r)=>{r.d(t,{Z:()=>o,a:()=>s});var n=r(7294);const i={},a=n.createContext(i);function s(e){const t=n.useContext(a);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),n.createElement(a.Provider,{value:t},e.children)}}}]);